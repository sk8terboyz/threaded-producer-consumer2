## Threaded Producer & Consumer

This is code from a class I took a couple years ago where all code was developed on Linux servers.

This program was created to fulfill homework/classroom requirements, not professional development.

The 'wordsEn.txt' file is just a file with an absurd amount of character strings that get read while the program runs. I was not able to copy over the entire file because it was so massive, so I copied a small portion of it.

Old README/Explanation:

In this program, we create a group of threads that are specified from the command line input to insert and remove words from a text document to a buffer. This occurs by the user running the code normally, then adding three parameters for the program to run. The first parameter is the time, in seconds, that the program should run. The second is the number of producer threads that should be created and the third is the number of consumer threads that should be created. When the correct command has been run, the arguments are saved into three separate variables. Then the file, "wordsEn.txt", is read into a character array. This is done by finding the size of the document using fseek() and ftell() so the array can be allocated with enough memory. The 2d array is then allocated with memory based off the size of the array and then filled with values. I tried a few different ways to get the correct values from the initial array, but ultimately I went simple and just scanned through the entire array checking what values were present and separating them accordingly. The file is then closed and the semaphore and mutex lock are initialized. The threads are then created using a loop to adjust for whatever value the user has entered. The main thread then goes to sleep for the allotted time (in seconds) the user specified. The producer threads then enter the insert_item() function where they sit in a never-ending loop. In this loop, a calculation is made using rand() and RAND_MAX, which is set to 10. This calculation gives the sleeping time for each thread, which should be anywhere from 0-10 seconds. The threads then enter a sem_wait() and mutex lock, allowing the threads to work safely together. Within the lock, a busy wait is set while a the buffer array is full, otherwise it inserts a random word from the document into the buffer. It will then output the producer thread ID and the word that was inserted to the user. For some reason this does have errors where it will print the last part of the sentence first and overwrite the first part. The mutex is then unlocked and sem_post() is called. On the other hand, the consumer threads enter a similar function called remove_item(). In this function the same sleeping calculation is done and semaphore/mutex locks are entered. The consumer threads will sleep for a random time (between 0-10 seconds). It will then remove a value from the buffer array and output that word to the user. Each thread will then leave the locked area by mutexes and semaphores. The infinite loops that each thread enters doesn't really matter though, because the time specified by the user will always run out and the program is immediately exited once this is done.
